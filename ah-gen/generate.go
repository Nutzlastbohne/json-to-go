package main

import (
	"encoding/json"
	"fmt"
	"github.com/a-h/generate"
	"github.com/a-h/generate/jsonschema"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const root = "D:/Dev/workspace/go/json-to-struct"
const personSchemaFile = root + "/schemas/person.json"
const arrRefSchemaFile = root + "/schemas/arrayRef.json"
const arrPersonRefSchemaFile = root + "/schemas/arrayPersonRef.json"
const target = "."

func main() {
	fmt.Println("a-h generator")

	//ToStruct(personSchemaFile)
	//ToStruct(arrRefSchemaFile)
	ToStruct(arrPersonRefSchemaFile)
}

func ToStruct(filepath string) {
	var err error
	var fileSchema *jsonschema.Schema
	fmt.Printf("\n--- generate struct for %v ---\n", filepath)
	fmt.Printf("inflate\n")
	inflatedBytes, err := inflateJson(filepath)

	if err != nil {
		log.Panicf("inflating json failed")
	}

	if fileSchema, err = jsonschema.Parse(string(inflatedBytes)); err != nil {
		log.Panicf("parsing fileSchema failed: %v", err)
	}

	gen := generate.New(fileSchema)

	structs, aliases, err := gen.CreateTypes()

	if err != nil {
		log.Panicf("creating types failed: %v", err)
	}

	//fmt.Printf("\nstructs:\n%+v\n", structs)
	//prettyPrint(structs)
	//fmt.Printf("\naliases:\n%+v\n", aliases)
	//prettyPrint(aliases)
	output(os.Stdout, structs, aliases)
}
func inflateJson(jsonPath string) ([]byte, error) {
	rawJson := loadRawJson(jsonPath)
	inflatedJson := seekDestroy(jsonPath, rawJson)
	return json.Marshal(inflatedJson)
}

func seekDestroy(jsonPath string, rawJson map[string]interface{}) map[string]interface{} {
	var refPath string
	//var err error
	var ok bool
	resolvedJson := make(map[string]interface{})

	for key, value := range rawJson {
		if key == "$ref" {
			if refPath, ok = value.(string); !ok {
				log.Panicf("invalid $ref file: %v", refPath)
			}

			if refPath[0] == '#' {
				log.Printf("file internal reference found - will be handled by a-h gen")
				resolvedJson[key] = value
				continue
			}

			if strings.Contains(refPath, "#") {
				log.Printf("WARN - sub-file references not supported yet.") // more likely a panic?
				continue
			}

			if !filepath.IsAbs(refPath) {
				refPath = filepath.Dir(jsonPath) + "/" + refPath
			}

			refJson := loadRawJson(refPath)
			resolvedRefJson := seekDestroy(jsonPath, refJson)

			// add to current node
			for refKey, refVal := range resolvedRefJson {
				resolvedJson[refKey] = refVal
			}
		} else if nestedMap, isMap := value.(map[string]interface{}); isMap {
			resolvedNestedMap := seekDestroy(jsonPath, nestedMap)
			resolvedJson[key] = resolvedNestedMap
		} else {
			resolvedJson[key] = value
		}
	}

	return resolvedJson
}

func loadRawJson(refPath string) map[string]interface{} {
	var fileBytes []byte
	var err error

	if fileBytes, err = ioutil.ReadFile(refPath); err != nil {
		log.Panicf("reading file failed: %v", err)
	}
	var refJson map[string]interface{}
	if err = json.Unmarshal(fileBytes, &refJson); err != nil {
		log.Panicf("unmarshalling referenced json failed: %v", err)
	}
	return refJson
}

func prettyPrint(thing interface{}) {
	stringThing := fmt.Sprintf("%+v", thing)
	formattedThing, err := format.Source([]byte(stringThing))

	if err != nil {
		fmt.Printf("prettyPrint failed: %v", err)
	}

	fmt.Printf("%v\n", formattedThing)
}

func output(w io.Writer, structs map[string]generate.Struct, aliases map[string]generate.Field) {
	fmt.Fprintln(w, "// Code generated by schema-generate. DO NOT EDIT.")
	fmt.Fprintln(w)
	fmt.Fprintf(w, "package main\n")

	for _, k := range getOrderedFieldNames(aliases) {
		a := aliases[k]

		fmt.Fprintln(w, "")
		fmt.Fprintf(w, "// %s\n", a.Name)
		fmt.Fprintf(w, "type %s %s\n", a.Name, a.Type)
	}

	for _, k := range getOrderedStructNames(structs) {
		s := structs[k]

		fmt.Fprintln(w, "")
		outputNameAndDescriptionComment(s.Name, s.Description, w)
		fmt.Fprintf(w, "type %s struct {\n", s.Name)

		for _, fieldKey := range getOrderedFieldNames(s.Fields) {
			f := s.Fields[fieldKey]

			// Only apply omitempty if the field is not required.
			omitempty := ",omitempty"
			if f.Required {
				omitempty = ""
			}

			fmt.Fprintf(w, "  %s %s `json:\"%s%s\"`\n", f.Name, f.Type, f.JSONName, omitempty)
		}

		fmt.Fprintln(w, "}")
	}
}

func outputNameAndDescriptionComment(name, description string, w io.Writer) {
	if strings.Index(description, "\n") == -1 {
		fmt.Fprintf(w, "// %s %s\n", name, description)
		return
	}

	dl := strings.Split(description, "\n")
	fmt.Fprintf(w, "// %s %s\n", name, strings.Join(dl, "\n// "))
}


func getOrderedFieldNames(m map[string]generate.Field) []string {
	keys := make([]string, len(m))
	idx := 0
	for k := range m {
		keys[idx] = k
		idx++
	}
	sort.Strings(keys)
	return keys
}

func getOrderedStructNames(m map[string]generate.Struct) []string {
	keys := make([]string, len(m))
	idx := 0
	for k := range m {
		keys[idx] = k
		idx++
	}
	sort.Strings(keys)
	return keys
}